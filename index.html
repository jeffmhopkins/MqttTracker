<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Meshtastic GPS Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous"/>
  <style>
    body, html { margin:0; padding:0; height:100%; font-family:Arial, sans-serif; overflow:hidden; }
    #app { display:flex; flex-direction:column; height:100%; }
    #map { flex:1; }
    #messages { flex:1; overflow-y:auto; padding:10px; background:#f8f8f8; display:none; color:#000; }
    .msg { margin:8px 0; padding:10px; border-radius:10px; max-width:80%; }
    .msg.sent { background:#dcf8c6; align-self:flex-end; margin-left:auto; }
    .msg.received { background:#ffffff; border:1px solid #ddd; margin-right:auto; }
    #input-area { position:fixed; bottom:60px; left:0; right:0; background:#fff; border-top:1px solid #ccc; display:none; padding:8px; box-sizing:border-box; }
    #msg-input { width:65%; padding:10px; border:1px solid #ccc; border-radius:5px; }
    #input-area button { width:32%; padding:10px; background:#007aff; color:white; border:none; border-radius:5px; margin-left:8px; }
    #bottom-bar { position:fixed; bottom:0; width:100%; height:60px; background:#f0f0f0; border-top:1px solid #ccc; display:flex; justify-content:space-around; align-items:center; z-index:999; flex-wrap:wrap; }
    #bottom-bar button { padding:8px 12px; background:#444; color:white; border:none; border-radius:6px; font-size:13px; cursor:pointer; min-width:90px; margin:4px; }
    #bottom-bar button.active { background:#007aff; }
    #status { position:fixed; top:0; left:0; right:0; background:rgba(0,0,0,0.75); color:#fff; padding:10px; text-align:center; z-index:1000; display:none; font-size:14px; }

    /* Messages Modal */
    #modal-messages {
      position:fixed; inset:0; background:rgba(0,0,0,0.85); z-index:2000; display:none; flex-direction:column; color:#fff;
    }
    #modal-messages.show { display:flex; }
    #modal-header {
      background:#1e1e1e; padding:12px 16px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #333;
    }
    #modal-header h2 { margin:0; font-size:1.2rem; }
    #close-modal { background:none; border:none; color:#fff; font-size:1.8rem; cursor:pointer; padding:0 8px; }
    #channel-select-container { display:flex; align-items:center; gap:10px; }
    #channel-select { padding:8px 12px; font-size:1rem; background:#333; color:#fff; border:1px solid #555; border-radius:6px; }
    #chat-container {
      flex:1; overflow-y:auto; padding:16px; background:#111; display:flex; flex-direction:column; gap:12px;
    }
    .chat-msg {
      max-width:80%; padding:10px 14px; border-radius:18px; font-size:0.95rem; line-height:1.4; word-break:break-word;
    }
    .chat-msg.sent { background:#007aff; color:white; align-self:flex-end; }
    .chat-msg.received { background:#333; color:#fff; align-self:flex-start; }
    .chat-meta { font-size:0.75rem; color:#aaa; margin-top:4px; opacity:0.8; }
    #chat-input-area {
      padding:12px 16px; background:#1e1e1e; border-top:1px solid #333; display:flex; gap:10px;
    }
    #chat-input { flex:1; padding:12px; border:1px solid #555; border-radius:8px; background:#222; color:#fff; font-size:1rem; outline:none; }
    #chat-send { padding:12px 20px; background:#007aff; color:white; border:none; border-radius:8px; cursor:pointer; font-weight:bold; }

    #config { 
      position:fixed; inset:0; background:#1e1e1e; color:#e0e0e0; padding:20px; overflow-y:auto; z-index:1001; display:none; 
    }
    #config.show { display:block; }
    #config label { display:block; margin:14px 0 6px; font-weight:bold; color:#ddd; }
    #config input, #config select { 
      width:100%; padding:10px; box-sizing:border-box; border:1px solid #444; border-radius:4px; background:#2d2d2d; color:#fff; 
    }
    #config button { 
      padding:10px 20px; margin:10px 10px 0 0; border:none; border-radius:6px; cursor:pointer; font-weight:bold; 
    }
    #config button:first-child { background:#007aff; color:white; }
    #config button:last-child { background:#444; color:#ddd; }
    #config .checkbox-label { display:flex; align-items:center; margin:10px 0; }
    #config .checkbox-label input { width:auto; margin-right:10px; }
    #precision-label { font-size: 0.9em; color: #aaa; margin-top: -8px; margin-bottom: 10px; }
  </style>
</head>
<body>
  <div id="app">
    <div id="status"></div>
    <div id="map"></div>
    <div id="messages"></div>

    <!-- Messages Modal -->
    <div id="modal-messages">
      <div id="modal-header">
        <div id="channel-select-container">
          <label for="channel-select">Channel:</label>
          <select id="channel-select">
            <option value="LongFast">LongFast</option>
            <!-- Add more channels here later if needed -->
          </select>
        </div>
        <h2>Channel Chat</h2>
        <button id="close-modal">×</button>
      </div>
      <div id="chat-container"></div>
      <div id="chat-input-area">
        <input id="chat-input" placeholder="Type your message..." autocomplete="off" />
        <button id="chat-send">Send</button>
      </div>
    </div>

    <div id="bottom-bar">
      <button id="btn-send" onclick="manualSendPosition()">Send Position</button>
      <button id="btn-track" onclick="toggleTracking()">Start Tracking</button>
      <button onclick="showMessagesModal()">Messages</button>
      <button onclick="showConfig()">Settings</button>
      <button onclick="sendFakePosition()">Send Fake Pos</button>
    </div>
  </div>

  <div id="config">
    <h2>Meshtastic Tracker Config</h2>
    <label>MQTT Broker (ws:// or wss://host:port)</label>
    <input id="mqtt-server" value="wss://mqtt.kc3efj.net:9001" />
    <label>Username (optional)</label>
    <input id="mqtt-user" value="scmesh" />
    <label>Password (optional)</label>
    <input id="mqtt-pass" type="password" />
    <label>Root Topic</label>
    <input id="root-topic" value="msh/US/FL" />
    <label>Channel Name (e.g. LongFast, MediumFast)</label>
    <input id="channel-name" value="LongFast" />
    <label>Channel PSK (base64 - for encrypted channels)</label>
    <input id="channel-psk" placeholder="Base64 encoded 32-byte key" value="AQ==" />
    <label>Your Node Name</label>
    <input id="node-name" value="WebTracker" />
    <label id="precision-label">Position Precision (decimal places) – ~111 km</label>
    <input id="precision" type="range" min="0" max="7" value="6" oninput="updatePrecisionLabel(this.value)" />
    <label>Tracking Interval (seconds - 0 = manual)</label>
    <input id="interval" type="number" min="0" value="600" />
    <label>Use JSON mode</label>
    <select id="use-json">
      <option value="true">Yes (JSON)</option>
      <option value="false" selected>No (raw protobuf)</option>
    </select>
    <div class="checkbox-label">
      <input type="checkbox" id="verbose-logging" checked />
      <label for="verbose-logging">Enable verbose logging (recommended for debug)</label>
    </div>
    <br><br>
    <button onclick="saveConfig()">Save & Connect</button>
    <button onclick="hideConfig()">Cancel</button>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script src="https://unpkg.com/protobufjs@7.2.6/dist/protobuf.min.js"></script>

  <script>
    const protoDefs = `
syntax = "proto3";
package meshtastic;

enum PortNum {
  PORTNUM_UNDEFINED = 0;
  TEXT_MESSAGE_APP = 1;
  POSITION_APP = 3;
  NODEINFO_APP = 4;
}

message Position {
  sfixed32 latitudeI = 1;
  sfixed32 longitudeI = 2;
  int32 altitude = 3;
  fixed32 time = 4;
  uint32 precision_bits = 23;
}

message User {
  string id = 1;
  string long_name = 2;
  string short_name = 3;
  uint32 hw_model = 4;
  bytes public_key = 5;
  string macaddr = 6;
}

message Data {
  PortNum portnum = 1;
  bytes payload = 2;
}

message MeshPacket {
  fixed32 from = 1;
  fixed32 to = 2;
  uint32 channel = 3;
  oneof payloadVariant {
    Data decoded = 4;
    bytes encrypted = 5;
  }
  uint32 id = 6;
}

message ServiceEnvelope {
  MeshPacket packet = 1;
  string channel_id = 2;
}
    `;
    let root = protobuf.parse(protoDefs).root;
    const Position = root.lookupType("meshtastic.Position");
    const User = root.lookupType("meshtastic.User");
    const Data = root.lookupType("meshtastic.Data");
    const MeshPacket = root.lookupType("meshtastic.MeshPacket");
    const ServiceEnvelope = root.lookupType("meshtastic.ServiceEnvelope");

    let map, myMarker, markers = {}, client, watchId = null, isTracking = false;
    let config = JSON.parse(localStorage.getItem('meshConfig')) || {};
    let myNodeId = parseInt(localStorage.getItem('myNodeId') || Math.floor(Math.random() * 0xffffffff));
    let myNodeIdHex = '!' + myNodeId.toString(16).padStart(8, '0');

    const statusEl = document.getElementById('status');
    const btnTrack = document.getElementById('btn-track');
    let verbose = true;

    // Channel messages storage: { channelName: [ {nodeId, text, time, isSent} ] }
    let channelMessages = { LongFast: [] };

    function log(...args) {
      if (verbose) console.log('[MeshTracker]', ...args);
    }

    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
    }

    function showStatus(msg, duration = 4000) {
      statusEl.textContent = msg;
      statusEl.style.display = 'block';
      setTimeout(() => statusEl.style.display = 'none', duration);
    }

    function updatePrecisionLabel(value) {
      const meters = (111000 / Math.pow(10, value)).toFixed(0);
      document.getElementById('precision-label').textContent = 
        `Position Precision (decimal places) – ~${meters} m`;
    }

    function base64ToBytes(b64) {
      if (!b64) return null;
      try {
        const bin = atob(b64.replace(/-/g,'+').replace(/_/g,'/'));
        let arr = Uint8Array.from(bin, c => c.charCodeAt(0));
        if (arr.length !== 32) {
          log(`PSK length ${arr.length} != 32 - padding with zeros for test`);
          const padded = new Uint8Array(32);
          arr.copyWithin(padded, 0, Math.min(arr.length, 32));
          arr = padded;
        }
        return arr;
      } catch (e) {
        log("Invalid base64 PSK:", e);
        return null;
      }
    }

    async function decryptPayload(encrypted, psk, fromNode, packetId) {
      const nonce = new Uint8Array(16);
      const dv = new DataView(nonce.buffer);
      dv.setUint32(0, fromNode, true);
      dv.setUint32(4, packetId, true);

      try {
        const key = await crypto.subtle.importKey("raw", psk, {name: "AES-CTR"}, false, ["decrypt"]);
        const decrypted = await crypto.subtle.decrypt(
          {name: "AES-CTR", counter: nonce, length: 128},
          key,
          encrypted
        );
        return new Uint8Array(decrypted);
      } catch (e) {
        log("Decryption failed:", e.message);
        return null;
      }
    }

    function showConfig() { 
      document.getElementById('config').classList.add('show'); 
      updatePrecisionLabel(document.getElementById('precision').value);
    }
    function hideConfig() { document.getElementById('config').classList.remove('show'); }

    function loadConfigUI() {
      document.getElementById('mqtt-server').value = config.server || 'wss://mqtt.kc3efj.net:9001';
      document.getElementById('mqtt-user').value = config.user || 'scmesh';
      document.getElementById('mqtt-pass').value = config.pass || '';
      document.getElementById('root-topic').value = config.root || 'msh/US/FL';
      document.getElementById('channel-name').value = config.channelName || 'LongFast';
      document.getElementById('channel-psk').value = config.psk || 'AQ==';
      document.getElementById('node-name').value = config.name || 'WebTracker';
      document.getElementById('precision').value = config.precision ?? 6;
      document.getElementById('interval').value = config.interval ?? 600;
      document.getElementById('use-json').value = config.useJson !== false ? 'true' : 'false';
      document.getElementById('verbose-logging').checked = true;
      verbose = true;
      updatePrecisionLabel(document.getElementById('precision').value);
    }

    function saveConfig() {
      config = {
        server: document.getElementById('mqtt-server').value.trim(),
        user: document.getElementById('mqtt-user').value.trim(),
        pass: document.getElementById('mqtt-pass').value.trim(),
        root: document.getElementById('root-topic').value.trim(),
        channelName: document.getElementById('channel-name').value.trim() || 'LongFast',
        psk: document.getElementById('channel-psk').value.trim(),
        name: document.getElementById('node-name').value.trim() || 'WebTracker',
        precision: parseInt(document.getElementById('precision').value),
        interval: parseInt(document.getElementById('interval').value),
        useJson: document.getElementById('use-json').value === 'true',
        verboseLogging: true
      };
      verbose = true;
      localStorage.setItem('meshConfig', JSON.stringify(config));
      localStorage.setItem('myNodeId', myNodeId);
      hideConfig();
      connectMQTT();
    }

    function showMap() {
      const mapEl = document.getElementById('map');
      if (!mapEl) {
        console.error("Map element not found!");
        showStatus("Error: Map container missing", 8000);
        return;
      }
      mapEl.style.display = 'block';
      const messagesEl = document.getElementById('messages');
      if (messagesEl) messagesEl.style.display = 'none';
      const inputAreaEl = document.getElementById('input-area');
      if (inputAreaEl) inputAreaEl.style.display = 'none';
      if (map) map.invalidateSize();
    }

    function showMessagesModal() {
      document.getElementById('modal-messages').classList.add('show');
      renderChatMessages(document.getElementById('channel-select').value);
      document.getElementById('chat-container').scrollTop = document.getElementById('chat-container').scrollHeight;
    }

    function hideMessagesModal() {
      document.getElementById('modal-messages').classList.remove('show');
    }

    function renderChatMessages(channel) {
      const container = document.getElementById('chat-container');
      container.innerHTML = '';
      const msgs = channelMessages[channel] || [];
      msgs.forEach(msg => {
        const div = document.createElement('div');
        div.className = `chat-msg ${msg.isSent ? 'sent' : 'received'}`;
        div.innerHTML = `
          <strong>${msg.isSent ? 'You' : msg.nodeId}</strong><br>
          ${msg.text.replace(/</g, '&lt;')}
          <div class="chat-meta">${new Date(msg.time).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</div>
        `;
        container.appendChild(div);
      });
      container.scrollTop = container.scrollHeight;
    }

    function addChatMessage(channel, fromHex, text, isSent = false) {
      if (!channelMessages[channel]) channelMessages[channel] = [];
      channelMessages[channel].push({
        nodeId: fromHex,
        text,
        time: Date.now(),
        isSent
      });
      if (document.getElementById('modal-messages').classList.contains('show') &&
          document.getElementById('channel-select').value === channel) {
        renderChatMessages(channel);
      }
    }

    async function sendText() {
      const input = document.getElementById('chat-input');
      const text = input.value.trim();
      if (!text || !client?.connected) return;

      const channel = document.getElementById('channel-select').value;
      const payload = new TextEncoder().encode(text);

      await sendProtobuf(payload, 1, channel);  // port 1 = TEXT_MESSAGE_APP

      addChatMessage(channel, myNodeIdHex, text, true);
      input.value = '';
    }

    document.getElementById('chat-send').onclick = sendText;
    document.getElementById('chat-input').addEventListener('keypress', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendText();
      }
    });

    document.getElementById('close-modal').onclick = hideMessagesModal;

    document.getElementById('channel-select').onchange = () => {
      renderChatMessages(document.getElementById('channel-select').value);
    };

    async function sendPosition(lat, lon, alt = 0) {
      if (!client?.connected) return showStatus("Not connected", 5000);

      const latI = Math.round(lat * 1e7) | 0;
      const lonI = Math.round(lon * 1e7) | 0;

      const pos = Position.create({
        latitudeI: latI,
        longitudeI: lonI,
        altitude: Math.round(alt),
        time: Math.floor(Date.now() / 1000),
        precision_bits: config.precision ?? 6
      });

      const payload = Position.encode(pos).finish();

      if (verbose) {
        log("Sending Position - latI:", latI, "lonI:", lonI, "alt:", alt);
        log("Position payload hex:", bytesToHex(payload));
      }

      await sendProtobuf(payload, 3);
      showStatus("Position sent");
    }

    async function sendFakePosition() {
      if (!client?.connected) {
        showStatus("Not connected to MQTT", 5000);
        return;
      }

      const centerLat = 28.554;
      const centerLon = -80.808;
      const offset = 0.027;
      const fakeLat = centerLat + (Math.random() * offset * 2 - offset);
      const fakeLon = centerLon + (Math.random() * offset * 2 - offset);
      const fakeAlt = 5;

      await sendPosition(fakeLat, fakeLon, fakeAlt);
      showStatus("Random fake position sent (near Port Saint John, FL)");
    }

    async function manualSendPosition() {
      navigator.geolocation.getCurrentPosition(
        pos => sendPosition(pos.coords.latitude, pos.coords.longitude, pos.coords.altitude || 0),
        err => showStatus("GPS error: " + err.message, 6000),
        {enableHighAccuracy: true, timeout: 8000}
      );
    }

    function toggleTracking() {
      isTracking = !isTracking;
      btnTrack.textContent = isTracking ? "Stop Tracking" : "Start Tracking";
      btnTrack.classList.toggle('active', isTracking);
      if (isTracking) startContinuousTracking();
      else stopContinuousTracking();
    }

    function startContinuousTracking() {
      if (watchId) navigator.geolocation.clearWatch(watchId);
      watchId = navigator.geolocation.watchPosition(
        pos => {
          const {latitude, longitude, altitude = 0} = pos.coords;
          updateMyMarker(latitude, longitude);
          sendPosition(latitude, longitude, altitude);
        },
        err => log("GPS watch error:", err),
        {enableHighAccuracy: true, timeout: 10000, maximumAge: 5000}
      );
      showStatus("Tracking started");
    }

    function stopContinuousTracking() {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      showStatus("Tracking stopped");
    }

    async function sendProtobuf(payloadBytes, portNum, targetChannel = config.channelName) {
      const data = Data.create({portnum: portNum, payload: payloadBytes});
      const packet = MeshPacket.create({
        from: myNodeId,
        to: 0xffffffff,
        channel: 0,
        decoded: data,
        id: Math.floor(Math.random() * 0xffffffff) >>> 0,
        hop_limit: 3
      });

      const finalBytes = MeshPacket.encode(packet).finish();

      const channelPath = config.useJson ? 'json/mqtt' : '2/e/mqtt';
      const topic = `${config.root}/${channelPath}/${targetChannel}/${myNodeIdHex}`;

      client.publish(topic, finalBytes, {qos: 0}, (err) => {
        if (err) log("Publish failed:", err);
        else if (verbose) log(`Published to ${topic} (port ${portNum})`);
      });
    }

    function updateMarker(nodeIdHex, lat, lon, extra = '', isMe = false) {
      let marker = markers[nodeIdHex];
      if (!marker) {
        marker = L.circleMarker([lat, lon], {
          color: isMe ? 'blue' : 'gray',
          radius: isMe ? 12 : 8,
          fillOpacity: 0.8
        }).addTo(map);
        markers[nodeIdHex] = marker;
      }
      marker.setLatLng([lat, lon]);
      marker.bindPopup(
        `${nodeIdHex}<br>${extra || 'Unknown'}<br>${lat.toFixed(6)}, ${lon.toFixed(6)}${isMe ? ' (You)' : ''}`
      );
      if (isMe) {
        map.panTo([lat, lon], {animate: true});
      }
    }

    function updateMyMarker(lat, lon) {
      updateMarker(myNodeIdHex, lat, lon, config.name || 'WebTracker', true);
    }

    function initMap() {
      const mapEl = document.getElementById('map');
      if (!mapEl) {
        console.error("Map element not found!");
        showStatus("Error: Map container missing", 8000);
        return;
      }
      map = L.map('map').setView([28.38, -80.60], 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      }).addTo(map);
      myMarker = L.circleMarker([28.38, -80.60], {color: 'blue', radius: 10, fillOpacity: 0.7})
        .addTo(map).bindPopup("You (last known)");
    }

    async function processPacket(packet, topic) {
      try {
        log(`Received on topic: ${topic}`);
        log(`Raw envelope/packet length: ${new Uint8Array(packet).length} bytes`);

        let payloadBytes;
        let fromHex = '!' + (packet.from >>> 0).toString(16).padStart(8, '0');

        if (packet.encrypted && packet.encrypted.length > 0) {
          log(`Encrypted payload detected (${packet.encrypted.length} bytes)`);
          const pskB = base64ToBytes(config.psk);
          if (!pskB) {
            log("Skipping - no valid PSK");
            return;
          }
          payloadBytes = await decryptPayload(packet.encrypted, pskB, packet.from, packet.id);
          if (!payloadBytes) return;
          log(`Decrypted successfully - payload length: ${payloadBytes.length} bytes`);
          log(`Decrypted hex: ${bytesToHex(payloadBytes)}`);
        } else if (packet.decoded && packet.decoded.payload) {
          payloadBytes = packet.decoded.payload;
          log(`Cleartext payload: ${payloadBytes.length} bytes`);
          log(`Cleartext hex: ${bytesToHex(payloadBytes)}`);
        } else {
          log("No valid payload (encrypted or decoded)");
          return;
        }

        const port = packet.decoded?.portnum || 0;
        log(`PortNum: ${port}`);

        let channel = topic.split('/')[3] || config.channelName;

        if (port === 3) {
          try {
            const pos = Position.decode(payloadBytes);
            log("Position decoded - raw fields:");
            log(`  latitudeI: ${pos.latitudeI ?? 'missing'}`);
            log(`  longitudeI: ${pos.longitudeI ?? 'missing'}`);
            log(`  altitude: ${pos.altitude ?? 'missing'}`);
            log(`  time: ${pos.time ?? 'missing'}`);
            log(`  precision_bits: ${pos.precision_bits ?? 'missing'}`);

            const latRaw = pos.latitudeI ?? 0;
            const lonRaw = pos.longitudeI ?? 0;
            const lat = latRaw / 1e7;
            const lon = lonRaw / 1e7;

            if (latRaw === 0 && lonRaw === 0) {
              log("Empty/zero position - skipping plot");
            } else if (Math.abs(lat) > 90 || Math.abs(lon) > 180 || isNaN(lat) || isNaN(lon)) {
              log("Invalid lat/lon values");
            } else {
              log(`Valid position: lat=${lat.toFixed(6)}, lon=${lon.toFixed(6)}`);
              updateMarker(fromHex, lat, lon, `Alt: ${pos.altitude || 'N/A'}m`, fromHex === myNodeIdHex);
            }
          } catch (e) {
            log("Position decode failed:", e.message);
          }
        } else if (port === 1) {
          try {
            const text = new TextDecoder().decode(payloadBytes);
            log(`Text message: "${text}" from ${fromHex}`);
            addChatMessage(channel, fromHex, text, false);
          } catch (e) {
            log("Text decode failed");
          }
        } else if (port === 4) {
          try {
            const user = User.decode(payloadBytes);
            log(`NodeInfo - long_name: ${user.long_name || 'N/A'}, short_name: ${user.short_name || 'N/A'}`);
            if (markers[fromHex]) markers[fromHex].bindPopup(user.long_name || fromHex);
          } catch (e) {
            log("NodeInfo decode failed:", e.message);
          }
        } else {
          log(`Unhandled PortNum ${port} - ${payloadBytes.length} bytes`);
        }
      } catch (e) {
        log("General packet processing error:", e.message);
      }
    }

    function connectMQTT() {
      if (!config.server) {
        showConfig();
        showStatus("Configure MQTT first");
        return;
      }
      const url = config.server.startsWith('wss://') ? config.server : `ws://${config.server}`;
      log(`Connecting to: ${url}`);
      showStatus("Connecting...");

      client = mqtt.connect(url, {
        username: config.user || undefined,
        password: config.pass || undefined,
        clientId: 'webtracker-' + Math.random().toString(16).slice(2,10),
        clean: true,
        reconnectPeriod: 5000
      });

      client.on('connect', () => {
        log("MQTT connected successfully");
        showStatus("Connected ✓");
        const subTopic = config.useJson ? `${config.root}/json/#` : `${config.root}/#`;
        client.subscribe(subTopic, err => {
          if (err) log("Subscribe failed");
          else log("Subscribed to:", subTopic);
        });
      });

      client.on('message', async (topic, message) => {
        try {
          const rawBytes = new Uint8Array(message);
          log(`Raw message length: ${rawBytes.length} bytes`);
          log(`Raw hex (first 64 bytes): ${bytesToHex(rawBytes.slice(0, 64))}${rawBytes.length > 64 ? '...' : ''}`);

          if (rawBytes[0] === 0x7b) {  // JSON detection
            const jsonStr = new TextDecoder().decode(rawBytes);
            log("Detected JSON payload:", jsonStr.substring(0, 500) + (jsonStr.length > 500 ? '...' : ''));
            try {
              const json = JSON.parse(jsonStr);
              log("Parsed JSON:", JSON.stringify(json, null, 2));

              const from = json.from || json.sender || 0;
              const fromHex = '!' + (from >>> 0).toString(16).padStart(8, '0');

              let lat = 0, lon = 0, alt = 0;
              if (json.payload) {
                lat = (json.payload.latitude_i || json.payload.latitude || 0) / 1e7;
                lon = (json.payload.longitude_i || json.payload.longitude || 0) / 1e7;
                alt = json.payload.altitude || json.payload.alt || 0;
              } else if (json.latitude_i !== undefined) {
                lat = (json.latitude_i || 0) / 1e7;
                lon = (json.longitude_i || 0) / 1e7;
                alt = json.altitude || 0;
              }

              if (lat !== 0 && lon !== 0 && !isNaN(lat) && !isNaN(lon)) {
                log(`JSON Position from ${fromHex}: lat=${lat.toFixed(6)}, lon=${lon.toFixed(6)}, alt=${alt}`);
                updateMarker(fromHex, lat, lon, `Alt: ${alt}m (JSON from ${json.type || 'unknown'})`, fromHex === myNodeIdHex);
              } else if (json.type === 'text' && json.payload?.text) {
                log(`JSON Text from ${fromHex}: "${json.payload.text}"`);
                const channel = topic.split('/')[3] || 'LongFast';
                addChatMessage(channel, fromHex, json.payload.text, false);
              } else {
                log("JSON - no position or text data");
              }
            } catch (e) {
              log("JSON parse failed:", e.message);
            }
            return;
          }

          let packet;
          try {
            packet = MeshPacket.decode(rawBytes);
            log("Decoded directly as MeshPacket");
          } catch (e) {
            try {
              const env = ServiceEnvelope.decode(rawBytes);
              packet = env.packet;
              log("Decoded as ServiceEnvelope → packet extracted");
            } catch (e2) {
              log("Failed to decode as MeshPacket or ServiceEnvelope");
              return;
            }
          }
          if (packet) await processPacket(packet, topic);
        } catch (e) {
          log("Message handler error:", e.message);
        }
      });

      client.on('error', err => {
        showStatus("MQTT error");
        log("MQTT error:", err);
      });

      client.on('close', () => {
        showStatus("Disconnected");
        log("MQTT connection closed");
      });
    }

    // Wait for DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      loadConfigUI();
      if (Object.keys(config).length > 0) {
        connectMQTT();
        showMap();
      } else {
        showConfig();
      }
    });
  </script>
</body>
</html>
