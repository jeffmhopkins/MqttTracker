<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Meshtastic GPS Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous"/>
  <style>
    body, html { margin:0; padding:0; height:100%; font-family:Arial, sans-serif; overflow:hidden; }
    #app { display:flex; flex-direction:column; height:100%; }
    #map { flex:1; }
    #messages { flex:1; overflow-y:auto; padding:10px; background:#f8f8f8; display:none; color:#000; }
    .msg { margin:8px 0; padding:10px; border-radius:10px; max-width:80%; }
    .msg.sent { background:#dcf8c6; align-self:flex-end; margin-left:auto; }
    .msg.received { background:#ffffff; border:1px solid #ddd; margin-right:auto; }
    #input-area { position:fixed; bottom:60px; left:0; right:0; background:#fff; border-top:1px solid #ccc; display:none; padding:8px; box-sizing:border-box; }
    #msg-input { width:65%; padding:10px; border:1px solid #ccc; border-radius:5px; }
    #input-area button { width:32%; padding:10px; background:#007aff; color:white; border:none; border-radius:5px; margin-left:8px; }
    #bottom-bar { position:fixed; bottom:0; width:100%; height:60px; background:#f0f0f0; border-top:1px solid #ccc; display:flex; justify-content:space-around; align-items:center; z-index:999; flex-wrap:wrap; }
    #bottom-bar button { padding:8px 12px; background:#444; color:white; border:none; border-radius:6px; font-size:13px; cursor:pointer; min-width:90px; margin:4px; }
    #bottom-bar button.active { background:#007aff; }
    #status { position:fixed; top:0; left:0; right:0; background:rgba(0,0,0,0.75); color:#fff; padding:10px; text-align:center; z-index:1000; display:none; font-size:14px; }
    #config { 
      position:fixed; inset:0; background:#1e1e1e; color:#e0e0e0; padding:20px; overflow-y:auto; z-index:1001; display:none; 
    }
    #config.show { display:block; }
    #config label { display:block; margin:14px 0 6px; font-weight:bold; color:#ddd; }
    #config input, #config select { 
      width:100%; padding:10px; box-sizing:border-box; border:1px solid #444; border-radius:4px; background:#2d2d2d; color:#fff; 
    }
    #config button { 
      padding:10px 20px; margin:10px 10px 0 0; border:none; border-radius:6px; cursor:pointer; font-weight:bold; 
    }
    #config button:first-child { background:#007aff; color:white; }
    #config button:last-child { background:#444; color:#ddd; }
    #config .checkbox-label { display:flex; align-items:center; margin:10px 0; }
    #config .checkbox-label input { width:auto; margin-right:10px; }
    #precision-label { font-size: 0.9em; color: #aaa; margin-top: -8px; margin-bottom: 10px; }
  </style>
</head>
<body>
  <div id="app">
    <div id="status"></div>
    <div id="map"></div>
    <div id="messages"></div>
    <div id="input-area">
      <input id="msg-input" placeholder="Type message to channel..." />
      <button onclick="sendText()">Send</button>
    </div>
    <div id="bottom-bar">
      <button id="btn-send" onclick="manualSendPosition()">Send Position</button>
      <button id="btn-track" onclick="toggleTracking()">Start Tracking</button>
      <button onclick="showConfig()">Settings</button>
      <button onclick="sendFakePosition()">Send Fake Pos (MQTT)</button>
    </div>
  </div>

  <div id="config">
    <h2>Meshtastic Tracker Config</h2>
    <label>MQTT Broker (ws:// or wss://host:port)</label>
    <input id="mqtt-server" value="ws://mqtt.kc3efj.net:9001" />
    <label>Username (optional)</label>
    <input id="mqtt-user" />
    <label>Password (optional)</label>
    <input id="mqtt-pass" type="password" />
    <label>Root Topic</label>
    <input id="root-topic" value="msh/US/FL" />
    <label>Channel Name (e.g. LongFast, MediumFast)</label>
    <input id="channel-name" value="LongFast" />
    <label>Channel PSK (base64 - for encrypted channels)</label>
    <input id="channel-psk" placeholder="Base64 encoded 32-byte key" value="AQ==" />
    <label>Your Node Name</label>
    <input id="node-name" value="WebTracker" />
    <label id="precision-label">Position Precision (decimal places) – ~111 km</label>
    <input id="precision" type="range" min="0" max="7" value="6" oninput="updatePrecisionLabel(this.value)" />
    <label>Tracking Interval (seconds - 0 = manual)</label>
    <input id="interval" type="number" min="0" value="600" />
    <label>Use JSON mode</label>
    <select id="use-json">
      <option value="true">Yes (JSON)</option>
      <option value="false" selected>No (raw protobuf)</option>
    </select>
    <div class="checkbox-label">
      <input type="checkbox" id="verbose-logging" checked />
      <label for="verbose-logging">Enable verbose logging (recommended for debug)</label>
    </div>
    <br><br>
    <button onclick="saveConfig()">Save & Connect</button>
    <button onclick="hideConfig()">Cancel</button>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script src="https://unpkg.com/protobufjs@7.2.6/dist/protobuf.min.js"></script>

  <script>
    const protoDefs = `
syntax = "proto3";
package meshtastic;

enum PortNum {
  PORTNUM_UNDEFINED = 0;
  TEXT_MESSAGE_APP = 1;
  POSITION_APP = 3;
  NODEINFO_APP = 4;
}

message Position {
  sfixed32 latitudeI = 1;
  sfixed32 longitudeI = 2;
  int32 altitude = 3;
  fixed32 time = 4;
  uint32 precision_bits = 23;
}

message User {
  string id = 1;
  string long_name = 2;
  string short_name = 3;
  uint32 hw_model = 4;
  bytes public_key = 5;
}

message Data {
  PortNum portnum = 1;
  bytes payload = 2;
}

message MeshPacket {
  fixed32 from = 1;
  fixed32 to = 2;
  uint32 channel = 3;
  oneof payloadVariant {
    Data decoded = 4;
    bytes encrypted = 5;
  }
  uint32 id = 6;
}

message ServiceEnvelope {
  MeshPacket packet = 1;
  string channel_id = 2;
}
    `;
    let root = protobuf.parse(protoDefs).root;
    const Position = root.lookupType("meshtastic.Position");
    const User = root.lookupType("meshtastic.User");
    const Data = root.lookupType("meshtastic.Data");
    const MeshPacket = root.lookupType("meshtastic.MeshPacket");
    const ServiceEnvelope = root.lookupType("meshtastic.ServiceEnvelope");

    let map, myMarker, markers = {}, client, watchId = null, intervalId = null, isTracking = false;
    let config = JSON.parse(localStorage.getItem('meshConfig')) || {};
    let myNodeId = parseInt(localStorage.getItem('myNodeId') || Math.floor(Math.random() * 0xffffffff));
    let myNodeIdHex = '!' + myNodeId.toString(16).padStart(8, '0');

    const statusEl = document.getElementById('status');
    const messagesDiv = document.getElementById('messages');
    const btnTrack = document.getElementById('btn-track');

    // Verbose is on by default now
    let verbose = true;

    function log(...args) {
      if (verbose) console.log('[MeshTracker]', ...args);
    }

    function bytesToHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
    }

    function showStatus(msg, duration = 4000) {
      statusEl.textContent = msg;
      statusEl.style.display = 'block';
      setTimeout(() => statusEl.style.display = 'none', duration);
    }

    function updatePrecisionLabel(value) {
      const meters = (111000 / Math.pow(10, value)).toFixed(0);
      document.getElementById('precision-label').textContent = 
        `Position Precision (decimal places) – ~${meters} m`;
    }

    function base64ToBytes(b64) {
      if (!b64) return null;
      try {
        const bin = atob(b64.replace(/-/g,'+').replace(/_/g,'/'));
        return Uint8Array.from(bin, c => c.charCodeAt(0));
      } catch (e) {
        log("Invalid base64 PSK:", e);
        return null;
      }
    }

    async function decryptPayload(encrypted, psk, fromNode, packetId) {
      const nonce = new Uint8Array(16);
      const dv = new DataView(nonce.buffer);
      dv.setUint32(0, fromNode, true);
      dv.setUint32(4, packetId, true);

      try {
        const key = await crypto.subtle.importKey("raw", psk, {name: "AES-CTR"}, false, ["decrypt"]);
        const decrypted = await crypto.subtle.decrypt(
          {name: "AES-CTR", counter: nonce, length: 128},
          key,
          encrypted
        );
        return new Uint8Array(decrypted);
      } catch (e) {
        log("Decryption failed:", e.message);
        return null;
      }
    }

    function showConfig() { 
      document.getElementById('config').classList.add('show'); 
      updatePrecisionLabel(document.getElementById('precision').value);
    }
    function hideConfig() { document.getElementById('config').classList.remove('show'); }

    function loadConfigUI() {
      document.getElementById('mqtt-server').value = config.server || 'ws://mqtt.kc3efj.net:9001';
      document.getElementById('mqtt-user').value = config.user || '';
      document.getElementById('mqtt-pass').value = config.pass || '';
      document.getElementById('root-topic').value = config.root || 'msh/US/FL';
      document.getElementById('channel-name').value = config.channelName || 'LongFast';
      document.getElementById('channel-psk').value = config.psk || 'AQ==';
      document.getElementById('node-name').value = config.name || 'WebTracker';
      document.getElementById('precision').value = config.precision ?? 6;
      document.getElementById('interval').value = config.interval ?? 600;
      document.getElementById('use-json').value = config.useJson !== false ? 'true' : 'false';
      document.getElementById('verbose-logging').checked = config.verboseLogging !== false; // default true
      verbose = document.getElementById('verbose-logging').checked;
      updatePrecisionLabel(document.getElementById('precision').value);
    }

    function saveConfig() {
      config = {
        server: document.getElementById('mqtt-server').value.trim(),
        user: document.getElementById('mqtt-user').value.trim(),
        pass: document.getElementById('mqtt-pass').value.trim(),
        root: document.getElementById('root-topic').value.trim(),
        channelName: document.getElementById('channel-name').value.trim() || 'LongFast',
        psk: document.getElementById('channel-psk').value.trim(),
        name: document.getElementById('node-name').value.trim() || 'WebTracker',
        precision: parseInt(document.getElementById('precision').value),
        interval: parseInt(document.getElementById('interval').value),
        useJson: document.getElementById('use-json').value === 'true',
        verboseLogging: document.getElementById('verbose-logging').checked
      };
      verbose = config.verboseLogging;
      localStorage.setItem('meshConfig', JSON.stringify(config));
      localStorage.setItem('myNodeId', myNodeId);
      hideConfig();
      connectMQTT();
    }

    function showMap() {
      document.getElementById('map').style.display = 'block';
      document.getElementById('messages').style.display = 'none';
      document.getElementById('input-area').style.display = 'none';
      if (map) map.invalidateSize();
    }

    function showMessages() {
      document.getElementById('map').style.display = 'none';
      document.getElementById('messages').style.display = 'block';
      document.getElementById('input-area').style.display = 'flex';
    }

    function initMap() {
      map = L.map('map').setView([28.38, -80.60], 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      }).addTo(map);
      myMarker = L.circleMarker([28.38, -80.60], {color: 'blue', radius: 10, fillOpacity: 0.7})
        .addTo(map).bindPopup("You (last known)");
    }

    function updateMarker(nodeIdHex, lat, lon, extra = '', isMe = false) {
      let marker = markers[nodeIdHex];
      if (!marker) {
        marker = L.circleMarker([lat, lon], {
          color: isMe ? 'blue' : 'gray',
          radius: isMe ? 12 : 8,
          fillOpacity: 0.8
        }).addTo(map);
        markers[nodeIdHex] = marker;
      }
      marker.setLatLng([lat, lon]);
      marker.bindPopup(
        `${nodeIdHex}<br>${extra || 'Unknown'}<br>${lat.toFixed(6)}, ${lon.toFixed(6)}${isMe ? ' (You)' : ''}`
      );
      if (isMe) {
        map.panTo([lat, lon], {animate: true});
      }
    }

    function updateMyMarker(lat, lon) {
      updateMarker(myNodeIdHex, lat, lon, config.name || 'WebTracker', true);
    }

    async function sendFakePosition() {
      if (!client?.connected) {
        showStatus("Not connected to MQTT", 5000);
        return;
      }

      const centerLat = 28.554;
      const centerLon = -80.808;
      const offset = 0.027;
      const fakeLat = centerLat + (Math.random() * offset * 2 - offset);
      const fakeLon = centerLon + (Math.random() * offset * 2 - offset);
      const fakeAlt = 5;

      await sendPosition(fakeLat, fakeLon, fakeAlt);
      showStatus("Random fake position sent (near Port Saint John, FL)");
    }

    async function manualSendPosition() {
      navigator.geolocation.getCurrentPosition(
        pos => sendPosition(pos.coords.latitude, pos.coords.longitude, pos.coords.altitude || 0),
        err => showStatus("GPS error: " + err.message, 6000),
        {enableHighAccuracy: true, timeout: 8000}
      );
    }

    function toggleTracking() {
      isTracking = !isTracking;
      btnTrack.textContent = isTracking ? "Stop Tracking" : "Start Tracking";
      btnTrack.classList.toggle('active', isTracking);
      if (isTracking) startContinuousTracking();
      else stopContinuousTracking();
    }

    function startContinuousTracking() {
      if (watchId) navigator.geolocation.clearWatch(watchId);
      watchId = navigator.geolocation.watchPosition(
        pos => {
          const {latitude, longitude, altitude = 0} = pos.coords;
          updateMyMarker(latitude, longitude);
          sendPosition(latitude, longitude, altitude);
        },
        err => log("GPS watch error:", err),
        {enableHighAccuracy: true, timeout: 10000, maximumAge: 5000}
      );
      showStatus("Tracking started");
    }

    function stopContinuousTracking() {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      showStatus("Tracking stopped");
    }

    async function sendPosition(lat, lon, alt = 0) {
      if (!client?.connected) return showStatus("Not connected", 5000);

      const latI = Math.round(lat * 1e7) | 0;
      const lonI = Math.round(lon * 1e7) | 0;

      const pos = Position.create({
        latitudeI: latI,
        longitudeI: lonI,
        altitude: Math.round(alt),
        time: Math.floor(Date.now() / 1000),
        precision_bits: config.precision ?? 6
      });

      const payload = Position.encode(pos).finish();

      if (verbose) {
        log("Sending Position - latI:", latI, "lonI:", lonI, "alt:", alt);
        log("Position payload hex:", bytesToHex(payload));
      }

      await sendProtobuf(payload, 3);
      showStatus("Position sent");
    }

    async function sendText() {
      const input = document.getElementById('msg-input');
      const text = input.value.trim();
      if (!text || !client?.connected) return;
      const payload = new TextEncoder().encode(text);
      await sendProtobuf(payload, 1);
      addMessage('You', text, true);
      input.value = '';
    }

    async function sendProtobuf(payloadBytes, portNum) {
      const data = Data.create({portnum: portNum, payload: payloadBytes});
      const packet = MeshPacket.create({
        from: myNodeId,
        to: 0xffffffff,
        channel: 0,
        decoded: data,
        id: Math.floor(Math.random() * 0xffffffff) >>> 0,
        hop_limit: 3
      });

      const finalBytes = MeshPacket.encode(packet).finish();

      const channelPath = config.useJson ? 'json' : '2/e';
      const topic = `${config.root}/${channelPath}/${config.channelName}/${myNodeIdHex}`;

      client.publish(topic, finalBytes, {qos: 0}, (err) => {
        if (err) log("Publish failed:", err);
        else if (verbose) log(`Published to ${topic} (port ${portNum})`);
      });
    }

    function addMessage(from, text, isSent = false) {
      const div = document.createElement('div');
      div.className = `msg ${isSent ? 'sent' : 'received'}`;
      div.innerHTML = `<strong>${from}</strong><br>${text.replace(/</g,'&lt;')}`;
      messagesDiv.appendChild(div);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    async function processPacket(packet, topic) {
      try {
        log(`Received on topic: ${topic}`);
        log(`Raw envelope/packet length: ${new Uint8Array(packet).length} bytes`);

        let payloadBytes;
        let fromHex = '!' + (packet.from >>> 0).toString(16).padStart(8, '0');

        if (packet.encrypted && packet.encrypted.length > 0) {
          log(`Encrypted payload detected (${packet.encrypted.length} bytes)`);
          const pskB = base64ToBytes(config.psk);
          if (!pskB || pskB.length !== 32) {
            log("Skipping - invalid PSK length");
            return;
          }
          payloadBytes = await decryptPayload(packet.encrypted, pskB, packet.from, packet.id);
          if (!payloadBytes) {
            log("Decryption failed or returned null");
            return;
          }
          log(`Decrypted successfully - payload length: ${payloadBytes.length} bytes`);
          log(`Decrypted hex: ${bytesToHex(payloadBytes)}`);
        } else if (packet.decoded && packet.decoded.payload) {
          payloadBytes = packet.decoded.payload;
          log(`Cleartext payload: ${payloadBytes.length} bytes`);
          log(`Cleartext hex: ${bytesToHex(payloadBytes)}`);
        } else {
          log("No valid payload (encrypted or decoded)");
          return;
        }

        const port = packet.decoded?.portnum || 0;
        log(`PortNum: ${port}`);

        if (port === 3) {
          try {
            const pos = Position.decode(payloadBytes);
            log("Position decoded - raw fields:");
            log(`  latitudeI: ${pos.latitudeI ?? 'missing'}`);
            log(`  longitudeI: ${pos.longitudeI ?? 'missing'}`);
            log(`  altitude: ${pos.altitude ?? 'missing'}`);
            log(`  time: ${pos.time ?? 'missing'}`);
            log(`  precision_bits: ${pos.precision_bits ?? 'missing'}`);

            const latRaw = pos.latitudeI ?? 0;
            const lonRaw = pos.longitudeI ?? 0;
            const lat = latRaw / 1e7;
            const lon = lonRaw / 1e7;

            if (latRaw === 0 && lonRaw === 0) {
              log("Empty/zero position - skipping plot");
            } else if (Math.abs(lat) > 90 || Math.abs(lon) > 180 || isNaN(lat) || isNaN(lon)) {
              log("Invalid lat/lon values");
            } else {
              log(`Valid position: lat=${lat.toFixed(6)}, lon=${lon.toFixed(6)}`);
              updateMarker(fromHex, lat, lon, `Alt: ${pos.altitude || 'N/A'}m`, fromHex === myNodeIdHex);
            }
          } catch (e) {
            log("Position decode failed:", e.message);
          }
        } else if (port === 1) {
          try {
            const text = new TextDecoder().decode(payloadBytes);
            log(`Text message: "${text}"`);
            addMessage(fromHex, text);
          } catch (e) {
            log("Text decode failed");
          }
        } else if (port === 4) {
          try {
            const user = User.decode(payloadBytes);
            log(`NodeInfo - long_name: ${user.long_name || 'N/A'}, short_name: ${user.short_name || 'N/A'}`);
            if (markers[fromHex]) markers[fromHex].bindPopup(user.long_name || fromHex);
          } catch (e) {
            log("NodeInfo decode failed");
          }
        } else {
          log(`Unhandled PortNum ${port} - ${payloadBytes.length} bytes`);
        }
      } catch (e) {
        log("General packet processing error:", e.message);
      }
    }

    function connectMQTT() {
      if (!config.server) {
        showConfig();
        showStatus("Configure MQTT first");
        return;
      }
      const url = config.server.startsWith('wss://') ? config.server : `ws://${config.server}`;
      log(`Connecting to: ${url}`);
      showStatus("Connecting...");

      client = mqtt.connect(url, {
        username: config.user || undefined,
        password: config.pass || undefined,
        clientId: 'webtracker-' + Math.random().toString(16).slice(2,10),
        clean: true,
        reconnectPeriod: 5000
      });

      client.on('connect', () => {
        log("MQTT connected successfully");
        showStatus("Connected ✓");
        const subTopic = config.useJson ? `${config.root}/json/#` : `${config.root}/#`;
        client.subscribe(subTopic, err => {
          if (err) log("Subscribe failed");
          else log("Subscribed to:", subTopic);
        });
      });

      client.on('message', async (topic, message) => {
        try {
          if (config.useJson) {
            log("JSON mode - raw message:", message.toString());
            // Add JSON parsing here later if needed
          } else {
            const rawBytes = new Uint8Array(message);
            log(`Raw message length: ${rawBytes.length} bytes`);
            log(`Raw hex (first 64 bytes): ${bytesToHex(rawBytes.slice(0, 64))}${rawBytes.length > 64 ? '...' : ''}`);

            let packet;
            try {
              packet = MeshPacket.decode(rawBytes);
              log("Decoded directly as MeshPacket");
            } catch (e) {
              try {
                const env = ServiceEnvelope.decode(rawBytes);
                packet = env.packet;
                log("Decoded as ServiceEnvelope → packet extracted");
              } catch (e2) {
                log("Failed to decode as MeshPacket or ServiceEnvelope");
                return;
              }
            }
            if (packet) await processPacket(packet, topic);
          }
        } catch (e) {
          log("Message handler error:", e.message);
        }
      });

      client.on('error', err => {
        showStatus("MQTT error");
        log("MQTT error:", err);
      });

      client.on('close', () => {
        showStatus("Disconnected");
        log("MQTT connection closed");
      });
    }

    initMap();
    loadConfigUI();
    if (Object.keys(config).length > 0) {
      connectMQTT();
      showMap();
    } else {
      showConfig();
    }
  </script>
</body>
</html>
