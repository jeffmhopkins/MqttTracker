<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Meshtastic GPS Tracker</title>

  <!-- PWA Meta Tags -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="MeshTracker">
  <meta name="theme-color" content="#000000">

  <!-- Inline Manifest (single-file PWA) -->
  <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogIk1lc2h0YXN0aWMgR1BTIFRyYWNrZXIiLAogICJzaG9ydF9uYW1lIjogIk1lc2hUcmFja2VyIiwKICAic3RhcnRfdXJsIjogIi4iLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMwMDAwMDAiLAogICJ0aGVtZV9jb2xvciI6ICIjMDA3YWZmIiwKICAib3JpZW50YXRpb24iOiAicG9ydHJhaXQtcHJpbWFyeSIsCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbCwm bHQ7c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDEwMCAxMDAnJmd0OyZsdDtjaXJjbGUgY3g9JzUwJyBjeT0nNTAnIHI9JzQwJyBmaWxsPScjMDA3YWZmJyAvJmd0OyZsdDt0ZXh0IHg9JzUwJyB5PSc1NScgZm9udC1zaXplPSc0MCcgdGV4dC1hbmNob3I9J21pZGRsZScgZmlsbD0nd2hpdGUnJmd0O00mbHQ7L3RleHQmZ3Q7Jmx0Oy9zdmcmZ3Q7IiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIiwKICAgICAgInB1cnBvc2UiOiAiYW55IG1hc2thYmxlIgogICAgfQogIF0KfQ==">
  <link rel="apple-touch-icon" href="data:image/svg+xml,&lt;svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'&gt;&lt;circle cx='50' cy='50' r='40' fill='%23007aff' /&gt;&lt;text x='50' y='55' font-size='40' text-anchor='middle' fill='white'&gt;M&lt;/text&gt;&lt;/svg&gt;">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous"/>

  <style>
    body, html { margin:0; padding:0; height:100%; font-family:Arial, sans-serif; overflow:hidden; }
    #app { display:flex; flex-direction:column; height:100%; }
    #map { flex:1; }
    #messages { flex:1; overflow-y:auto; padding:10px; background:#f8f8f8; display:none; color:#000; }
    .msg { margin:8px 0; padding:10px; border-radius:10px; max-width:80%; }
    .msg.sent { background:#dcf8c6; align-self:flex-end; margin-left:auto; }
    .msg.received { background:#ffffff; border:1px solid #ddd; margin-right:auto; }
    #input-area { position:fixed; bottom:60px; left:0; right:0; background:#fff; border-top:1px solid #ccc; display:none; padding:8px; box-sizing:border-box; }
    #msg-input { width:65%; padding:10px; border:1px solid #ccc; border-radius:5px; }
    #input-area button { width:32%; padding:10px; background:#007aff; color:white; border:none; border-radius:5px; margin-left:8px; }
    #bottom-bar { position:fixed; bottom:0; width:100%; height:60px; background:#f0f0f0; border-top:1px solid #ccc; display:flex; justify-content:space-around; align-items:center; z-index:999; flex-wrap:wrap; }
    #bottom-bar button { padding:8px 12px; background:#444; color:white; border:none; border-radius:6px; font-size:13px; cursor:pointer; min-width:90px; margin:4px; }
    #bottom-bar button.active { background:#007aff; }
    #status { position:fixed; top:0; left:0; right:0; background:rgba(0,0,0,0.75); color:#fff; padding:10px; text-align:center; z-index:1000; display:none; font-size:14px; }
    #config { 
      position:fixed; inset:0; background:#1e1e1e; color:#e0e0e0; padding:20px; overflow-y:auto; z-index:1001; display:none; 
    }
    #config.show { display:block; }
    #config label { display:block; margin:14px 0 6px; font-weight:bold; color:#ddd; }
    #config input, #config select { 
      width:100%; padding:10px; box-sizing:border-box; border:1px solid #444; border-radius:4px; background:#2d2d2d; color:#fff; 
    }
    #config button { 
      padding:10px 20px; margin:10px 10px 0 0; border:none; border-radius:6px; cursor:pointer; font-weight:bold; 
    }
    #config button:first-child { background:#007aff; color:white; }
    #config button:last-child { background:#444; color:#ddd; }
    #config .checkbox-label { display:flex; align-items:center; margin:10px 0; }
    #config .checkbox-label input { width:auto; margin-right:10px; }
    #precision-label { font-size: 0.9em; color: #aaa; margin-top: -8px; margin-bottom: 10px; }
  </style>
</head>
<body>
  <div id="app">
    <div id="status"></div>
    <div id="map"></div>
    <div id="messages"></div>
    <div id="input-area">
      <input id="msg-input" placeholder="Type message to channel..." />
      <button onclick="sendText()">Send</button>
    </div>
    <div id="bottom-bar">
      <button id="btn-send" onclick="manualSendPosition()">Send Position</button>
      <button id="btn-track" onclick="toggleTracking()">Start Tracking</button>
      <button onclick="showConfig()">Settings</button>
    </div>
  </div>

  <div id="config">
    <h2>Meshtastic Tracker Config</h2>
    <label>MQTT Broker (ws:// or wss://host:port)</label>
    <input id="mqtt-server" value="ws://mqtt.kc3efj.net:9001" />
    <label>Username (optional)</label>
    <input id="mqtt-user" />
    <label>Password (optional)</label>
    <input id="mqtt-pass" type="password" />
    <label>Root Topic</label>
    <input id="root-topic" value="msh/US/FL" />
    <label>Channel PSK (base64 - for encrypted channels)</label>
    <input id="channel-psk" placeholder="Base64 encoded 32-byte key" />
    <label>Your Node Name</label>
    <input id="node-name" value="WebTracker" />
    <label id="precision-label">Position Precision (decimal places) – ~111 km</label>
    <input id="precision" type="range" min="0" max="7" value="6" oninput="updatePrecisionLabel(this.value)" />
    <label>Tracking Interval (seconds - 0 = manual)</label>
    <input id="interval" type="number" min="0" value="600" />
    <label>Use JSON mode</label>
    <select id="use-json">
      <option value="true">Yes (JSON)</option>
      <option value="false" selected>No (raw protobuf)</option>
    </select>
    <div class="checkbox-label">
      <input type="checkbox" id="verbose-logging" />
      <label for="verbose-logging">Enable verbose logging</label>
    </div>
    <br><br>
    <button onclick="saveConfig()">Save & Connect</button>
    <button onclick="hideConfig()">Cancel</button>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script src="https://unpkg.com/protobufjs@7.2.6/dist/protobuf.min.js"></script>

  <script>
    const protoDefs = `
syntax = "proto3";
package meshtastic;

enum PortNum {
  PORTNUM_UNDEFINED = 0;
  TEXT_MESSAGE_APP = 1;
  POSITION_APP = 3;
  NODEINFO_APP = 4;
}

message Position {
  sfixed32 latitudeI = 1;
  sfixed32 longitudeI = 2;
  int32 altitude = 3;
  fixed32 time = 4;
  uint32 precision_bits = 23;
}

message User {
  string id = 1;
  string long_name = 2;
  string short_name = 3;
  uint32 hw_model = 4;
  bytes public_key = 5;
}

message Data {
  PortNum portnum = 1;
  bytes payload = 2;
}

message MeshPacket {
  fixed32 from = 1;
  fixed32 to = 2;
  uint32 channel = 3;
  oneof payloadVariant {
    Data decoded = 4;
    bytes encrypted = 5;
  }
  uint32 id = 6;
}

message ServiceEnvelope {
  MeshPacket packet = 1;
  string channel_id = 2;
}
    `;
    let root = protobuf.parse(protoDefs).root;
    const Position = root.lookupType("meshtastic.Position");
    const User = root.lookupType("meshtastic.User");
    const Data = root.lookupType("meshtastic.Data");
    const MeshPacket = root.lookupType("meshtastic.MeshPacket");
    const ServiceEnvelope = root.lookupType("meshtastic.ServiceEnvelope");

    let map, myMarker, markers = {}, client, watchId = null, intervalId = null, isTracking = false;
    let config = JSON.parse(localStorage.getItem('meshConfig')) || {};
    let myNodeId = parseInt(localStorage.getItem('myNodeId') || Math.floor(Math.random() * 0xffffffff));
    let myNodeIdHex = '!' + myNodeId.toString(16).padStart(8, '0');

    const statusEl = document.getElementById('status');
    const messagesDiv = document.getElementById('messages');
    const btnTrack = document.getElementById('btn-track');

    let verbose = config.verboseLogging || false;

    function log(...args) {
      if (verbose) console.log('[MeshTracker]', ...args);
    }

    function showStatus(msg, duration = 4000) {
      statusEl.textContent = msg;
      statusEl.style.display = 'block';
      setTimeout(() => statusEl.style.display = 'none', duration);
    }

    function updatePrecisionLabel(value) {
      const meters = (111000 / Math.pow(10, value)).toFixed(0);
      document.getElementById('precision-label').textContent = 
        `Position Precision (decimal places) – ~${meters} m`;
    }

    function base64ToBytes(b64) {
      if (!b64) return null;
      try {
        const bin = atob(b64.replace(/-/g,'+').replace(/_/g,'/'));
        return Uint8Array.from(bin, c => c.charCodeAt(0));
      } catch (e) {
        log("Invalid base64 PSK");
        return null;
      }
    }

    async function decryptPayload(encrypted, psk, fromNode, packetId) {
      const nonce = new Uint8Array(16);
      const dv = new DataView(nonce.buffer);
      dv.setUint32(0, fromNode, true);
      dv.setUint32(4, packetId, true);

      try {
        const key = await crypto.subtle.importKey("raw", psk, {name: "AES-CTR"}, false, ["decrypt"]);
        const decrypted = await crypto.subtle.decrypt(
          {name: "AES-CTR", counter: nonce, length: 128},
          key,
          encrypted
        );
        return new Uint8Array(decrypted);
      } catch (e) {
        return null;
      }
    }

    function showConfig() { 
      document.getElementById('config').classList.add('show'); 
      updatePrecisionLabel(document.getElementById('precision').value);
    }
    function hideConfig() { document.getElementById('config').classList.remove('show'); }

    function loadConfigUI() {
      document.getElementById('mqtt-server').value = config.server || 'ws://mqtt.kc3efj.net:9001';
      document.getElementById('mqtt-user').value = config.user || '';
      document.getElementById('mqtt-pass').value = config.pass || '';
      document.getElementById('root-topic').value = config.root || 'msh/US/FL';
      document.getElementById('channel-psk').value = config.psk || '';
      document.getElementById('node-name').value = config.name || 'WebTracker';
      document.getElementById('precision').value = config.precision ?? 6;
      document.getElementById('interval').value = config.interval ?? 600;
      document.getElementById('use-json').value = config.useJson !== false ? 'true' : 'false';
      document.getElementById('verbose-logging').checked = config.verboseLogging || false;
      verbose = document.getElementById('verbose-logging').checked;
      updatePrecisionLabel(document.getElementById('precision').value);
    }

    function saveConfig() {
      config = {
        server: document.getElementById('mqtt-server').value.trim(),
        user: document.getElementById('mqtt-user').value.trim(),
        pass: document.getElementById('mqtt-pass').value.trim(),
        root: document.getElementById('root-topic').value.trim(),
        psk: document.getElementById('channel-psk').value.trim(),
        name: document.getElementById('node-name').value.trim() || 'WebTracker',
        precision: parseInt(document.getElementById('precision').value),
        interval: parseInt(document.getElementById('interval').value),
        useJson: document.getElementById('use-json').value === 'true',
        verboseLogging: document.getElementById('verbose-logging').checked
      };
      verbose = config.verboseLogging;
      localStorage.setItem('meshConfig', JSON.stringify(config));
      localStorage.setItem('myNodeId', myNodeId);
      hideConfig();
      connectMQTT();
    }

    function showMap() {
      document.getElementById('map').style.display = 'block';
      document.getElementById('messages').style.display = 'none';
      document.getElementById('input-area').style.display = 'none';
      if (map) map.invalidateSize();
    }

    function showMessages() {
      document.getElementById('map').style.display = 'none';
      document.getElementById('messages').style.display = 'block';
      document.getElementById('input-area').style.display = 'flex';
    }

    function initMap() {
      map = L.map('map').setView([28.38, -80.60], 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      }).addTo(map);
      myMarker = L.circleMarker([28.38, -80.60], {color: 'blue', radius: 10, fillOpacity: 0.7})
        .addTo(map).bindPopup("You (last known)");
    }

    function updateMarker(nodeIdHex, lat, lon, extra = '', isMe = false) {
      let marker = markers[nodeIdHex];
      if (!marker) {
        marker = L.circleMarker([lat, lon], {
          color: isMe ? 'blue' : 'gray',
          radius: isMe ? 12 : 8,
          fillOpacity: 0.8
        }).addTo(map);
        markers[nodeIdHex] = marker;
      }
      marker.setLatLng([lat, lon]);
      marker.bindPopup(
        `${nodeIdHex}<br>${extra || 'Unknown'}<br>${lat.toFixed(6)}, ${lon.toFixed(6)}${isMe ? ' (You)' : ''}`
      );
      if (isMe) {
        map.panTo([lat, lon], {animate: true});
      }
    }

    function updateMyMarker(lat, lon) {
      updateMarker(myNodeIdHex, lat, lon, config.name || 'WebTracker', true);
    }

    async function manualSendPosition() {
      navigator.geolocation.getCurrentPosition(
        pos => sendPosition(pos.coords.latitude, pos.coords.longitude, pos.coords.altitude || 0),
        err => showStatus("GPS error: " + err.message, 6000),
        {enableHighAccuracy: true, timeout: 8000}
      );
    }

    function toggleTracking() {
      isTracking = !isTracking;
      btnTrack.textContent = isTracking ? "Stop Tracking" : "Start Tracking";
      btnTrack.classList.toggle('active', isTracking);
      if (isTracking) startContinuousTracking();
      else stopContinuousTracking();
    }

    function startContinuousTracking() {
      if (watchId) navigator.geolocation.clearWatch(watchId);
      watchId = navigator.geolocation.watchPosition(
        pos => {
          const {latitude, longitude, altitude = 0} = pos.coords;
          updateMyMarker(latitude, longitude);
          sendPosition(latitude, longitude, altitude);
        },
        err => log("GPS watch error:", err),
        {enableHighAccuracy: true, timeout: 10000, maximumAge: 5000}
      );
      showStatus("Tracking started");
    }

    function stopContinuousTracking() {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      showStatus("Tracking stopped");
    }

    async function sendPosition(lat, lon, alt = 0) {
      if (!client?.connected) return showStatus("Not connected", 5000);

      const latI = Math.round(lat * 1e7) | 0;
      const lonI = Math.round(lon * 1e7) | 0;

      const pos = Position.create({
        latitudeI: latI,
        longitudeI: lonI,
        altitude: Math.round(alt),
        time: Math.floor(Date.now() / 1000),
        precision_bits: 32
      });

      const payload = Position.encode(pos).finish();

      if (verbose) {
        log("Sent Position payload length:", payload.length);
        log("Sent Position payload hex:", Array.from(payload).map(b => b.toString(16).padStart(2,'0')).join(' '));
        log("Pre-encode values - lat_i:", latI, "lon_i:", lonI, "alt:", alt);
      }

      await sendProtobuf(payload, 3);
      showStatus("Position sent");
      if (verbose) log(`Sent position: lat=${lat.toFixed(6)}, lon=${lon.toFixed(6)}`);
    }

    async function sendText() {
      const input = document.getElementById('msg-input');
      const text = input.value.trim();
      if (!text || !client?.connected) return;
      const payload = new TextEncoder().encode(text);
      await sendProtobuf(payload, 1);
      addMessage('You', text, true);
      input.value = '';
      if (verbose) log(`Sent text: "${text}"`);
    }

    async function sendProtobuf(payloadBytes, portNum) {
      const data = Data.create({portnum: portNum, payload: payloadBytes});
      const packet = MeshPacket.create({
        from: myNodeId,
        to: 0xffffffff,
        channel: 0,
        decoded: data,
        id: Math.floor(Math.random() * 0xffffffff) >>> 0,
        hop_limit: 3
      });

      const finalBytes = MeshPacket.encode(packet).finish();

      const topic = `${config.root}/${config.useJson ? 'json/mqtt' : '2/e'}/${myNodeIdHex}`;
      client.publish(topic, finalBytes, {qos: 0});
      if (verbose) log(`Published to ${topic} (port ${portNum})`);
    }

    function addMessage(from, text, isSent = false) {
      const div = document.createElement('div');
      div.className = `msg ${isSent ? 'sent' : 'received'}`;
      div.innerHTML = `<strong>${from}</strong><br>${text.replace(/</g,'&lt;')}`;
      messagesDiv.appendChild(div);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    async function processPacket(packet, topic) {
      try {
        let payloadBytes;
        let fromHex = '!' + (packet.from >>> 0).toString(16).padStart(8, '0');

        if (packet.encrypted && packet.encrypted.length > 0) {
          const pskB = base64ToBytes(config.psk);
          if (!pskB || pskB.length !== 32) return;
          payloadBytes = await decryptPayload(packet.encrypted, pskB, packet.from, packet.id);
          if (!payloadBytes) return;
          if (verbose) log("Decrypted payload:", payloadBytes.length, "bytes");
        } else if (packet.decoded && packet.decoded.payload) {
          payloadBytes = packet.decoded.payload;
          if (verbose) log("Cleartext payload:", payloadBytes.length, "bytes");
        } else {
          return;
        }

        const port = packet.decoded?.portnum || 0;

        if (port === 3) {
          try {
            const pos = Position.decode(payloadBytes);
            if (verbose) {
              console.log("Raw Position fields:", JSON.stringify(pos));
              console.log("latitudeI present?", 'latitudeI' in pos, "value:", pos.latitudeI);
              console.log("longitudeI present?", 'longitudeI' in pos, "value:", pos.longitudeI);
            }

            const latRaw = pos.latitudeI ?? 0;
            const lonRaw = pos.longitudeI ?? 0;
            const lat = latRaw / 1e7;
            const lon = lonRaw / 1e7;

            if (verbose) {
              console.log("Raw latI:", latRaw, "→", lat.toFixed(8));
              console.log("Raw lonI:", lonRaw, "→", lon.toFixed(8));
              console.log("Altitude:", pos.altitude, "Time:", pos.time);
            }

            if (latRaw === 0 && lonRaw === 0) {
              log("Empty position received");
            } else if (Math.abs(lat) > 90 || Math.abs(lon) > 180 || isNaN(lat) || isNaN(lon)) {
              log("Invalid position received");
            } else {
              log("Valid position:", lat.toFixed(6), lon.toFixed(6));
              updateMarker(fromHex, lat, lon, `Alt: ${pos.altitude || 'N/A'}m`, fromHex === myNodeIdHex);
            }
          } catch (e) {
            log("Position decode failed:", e.message);
            if (verbose) log("Raw payload hex:", Array.from(payloadBytes).map(b => b.toString(16).padStart(2,'0')).join(' '));
          }
        } else if (port === 1) {
          try {
            const text = new TextDecoder().decode(payloadBytes);
            addMessage(fromHex, text);
            if (verbose) log("Text:", text);
          } catch (e) {}
        } else if (port === 4) {
          try {
            const user = User.decode(payloadBytes);
            if (markers[fromHex]) markers[fromHex].bindPopup(user.long_name || fromHex);
            if (verbose) log("NodeInfo:", user.long_name || user.short_name || fromHex);
          } catch (e) {}
        }
      } catch (e) {}
    }

    function connectMQTT() {
      if (!config.server) {
        showConfig();
        showStatus("Configure MQTT first");
        return;
      }
      const url = config.server.startsWith('wss://') ? config.server : `ws://${config.server}`;
      log(`Connecting to: ${url}`);
      showStatus("Connecting...");

      client = mqtt.connect(url, {
        username: config.user || undefined,
        password: config.pass || undefined,
        clientId: 'webtracker-' + Math.random().toString(16).slice(2,10),
        clean: true,
        reconnectPeriod: 5000
      });

      client.on('connect', () => {
        log("MQTT connected successfully");
        showStatus("Connected ✓");
        const subTopic = config.useJson ? `${config.root}/json/#` : `${config.root}/#`;
        client.subscribe(subTopic, err => {
          if (err) log("Subscribe failed");
          else log("Subscribed OK");
        });
      });

      client.on('message', async (topic, message) => {
        const rawBytes = new Uint8Array(message);
        try {
          if (config.useJson) {
            // JSON handling if needed later
          } else {
            let packet;
            try {
              packet = MeshPacket.decode(rawBytes);
            } catch (e) {
              try {
                const env = ServiceEnvelope.decode(rawBytes);
                packet = env.packet;
              } catch {}
            }
            if (packet) await processPacket(packet, topic);
          }
        } catch {}
      });

      client.on('error', err => {
        showStatus("MQTT error");
      });

      client.on('close', () => {
        showStatus("Disconnected");
      });
    }

    // Inline Service Worker for single-file PWA
    if ('serviceWorker' in navigator) {
      const swCode = `
        self.addEventListener('install', e => {
          e.waitUntil(
            caches.open('mesh-tracker-v1').then(cache => {
              return cache.addAll(['./']);
            })
          );
        });

        self.addEventListener('fetch', e => {
          e.respondWith(
            caches.match(e.request).then(response => {
              return response || fetch(e.request);
            })
          );
        });
      `;

      const blob = new Blob([swCode], {type: 'application/javascript'});
      const swUrl = URL.createObjectURL(blob);

      window.addEventListener('load', () => {
        navigator.serviceWorker.register(swUrl, {scope: './'})
          .then(reg => {
            if (verbose) log('Service Worker registered');
          })
          .catch(err => {
            if (verbose) log('Service Worker failed:', err);
          });
      });
    }

    initMap();
    loadConfigUI();
    if (Object.keys(config).length > 0) {
      connectMQTT();
      showMap();
    } else {
      showConfig();
    }
  </script>
</body>
</html>
